Тренадцатое(13). Вопросы
1) С++. Модульное программирование. Структура и пример проекта.
Структуры.
Выполнил: Герасимов Д.А. П1-18. 23.06.2020

Размер структур. Как правило, размер структуры — это сумма размеров всех её членов, но не всегда Например, рассмотрим структуру Employee. На большинстве платформ тип short занимает 2 байта, тип int — 4 байта, а тип double — 8 байт. Следовательно, ожидается, что Employee будет занимать 2 + 4 + 8 = 14 байт. Чтобы узнать точный размер Employee, мы можем воспользоваться оператором sizeof.
Формат объявления структуры выглядит так:
struct Car{ 
    int x_coor; 
    int y_coor; 
    string name;
};

Объявляя структуру, мы вводим в программу наш собственный тип данных, которым можем пользоваться, так же как и стандартными типами, т.е. объявление переменной нашего типа будет таким:
structName variableName;
structName — имя структуры, variableName — имя переменной.

x_coor, y_coor и name — поля нашей структуры. При объявлении структуры мы создаем составной тип данных, с помощью которого можно создавать переменные, которые сочетают в себе несколько значений (например, координаты и имя). Внутри структуры каждому полю мы даем имя, чтобы потом обращаться к этому значению по его имени.
Для доступа к полям структуры используется точка:
// объявляем переменную
Car myCar;
 
// и используем её
myCar.x_coor = 40;
myCar.y_coor = 40;
myCar.name = "Porche";
Как видите, вы можете хранить в структуре столько полей, сколько вам угодно и они могут иметь разные типы.
Рассмотрим пример, демонстрирующий сочетание массивов и структур.
#include <iostream>
using namespace std;
 
struct PlayerInfo {
    int skill_level;
    string name;
};
using namespace std;
 
int main() {
    // как и с обычными типами, вы можете объявить массив структур
    PlayerInfo players[5];
    for (int i = 0; i < 5; i++) {
        	cout << "Please enter the name for player : " << i << '\n'; 
       	 // сперва получим доступ к элементу массива, используя
       	 // обычный синтаксис для массивов, затем обратимся к полю структуры
        	// с помощью точки
        	cin >> players[ i ].name;
       	 cout << "Please enter the skill level for " << players[ i ].name << '\n';
        	cin >> players[ i ].skill_level;
    }
    	for (int i = 0; i < 5; ++i) {
       		 cout << players[ i ].name << " is at skill level " << players[i].skill_level << '\n';
    	}
}
Так же как и с простыми типами (int, например), вы можете создавать массивы структур. А с каждым элементом этого массива работать так же как и с отдельной переменной. Для доступа к полю name первого элемента массива структур, просто напишите:
players[ 0 ].name
Структуры и функции
Очень часто требуется писать функции, которые принимают структуры в качестве аргумента или возвращают структуру. Например, если вам надо написать небольшую космическую аркаду, вам может понадобится функция для инициализации нового противника:
struct EnemySpaceShip { 
    int x_coordinate;
    int y_coordinate;
    int weapon_power;
}; 
EnemySpaceShip getNewEnemy();
Функция getNewEnemy должна возвращать структуру с инициализированными полями:

EnemySpaceShip getNewEnemy (){ 
    	EnemySpaceShip ship;
    	ship.x_coordinate = 0;
    	ship.y_coordinate = 0;
    	ship.weapon_power = 20;
    	return ship;
}

На самом деле эта функция вернет копию созданной локальной переменной ship. Это значит, что каждое поле структуры будет скопировано в новую переменную. В нашем случае копирование малого количества полей не заметно, но когда вы работаете с большими объемами данных нужно избегать лишних действий, подробнее об этом поговорим в статье про указатели.
Таким образом, для получения новой переменной будем использовать следующий код:
EnemySpaceShip ship = getNewEnemy();
Теперь эту переменную можно использовать как обычную структуру.
Передавать структуры в функцию можно так:
EnemySpaceShip upgradeWeapons (EnemySpaceShip ship){ 
    	ship.weapon_power += 10;
   	 return ship;
}

Когда мы передаем структуру в функцию, она копируется, так же как и при возвращении структуры. Поэтому любые изменения сделанные внутри функции будут потеряны, поэтому мы возвращаем структуру после изменения.
Использование функции:
ship = upgradeWeapons(ship);
Когда вызывается функция, переменная ship копируется и изменяется в функции, а когда переменная возвращается, она снова копируется и перезаписывает поля оргинальной переменной.

И наконец, программа для создания и улучшения одного корабля:
struct EnemySpaceShip {
    	int x_coordinate;
    	int y_coordinate;
    	int weapon_power;
};
 
EnemySpaceShip getNewEnemy() {
   	 EnemySpaceShip ship;
    	ship.x_coordinate = 0;
    	ship.y_coordinate = 0;
    	ship.weapon_power = 20;
    	return ship;
}
 
EnemySpaceShip upgradeWeapons(EnemySpaceShip ship) {
    	ship.weapon_power += 10;
    	return ship;
}
 
int main() {
    	EnemySpaceShip enemy = getNewEnemy();
    	enemy = upgradeWeapons(enemy);
}
Указатели
Если вы работаете с указателем на структуру, то для доступа к переменным надо использовать оператор «->» вместо точки. Все свойства указателей не изменяются. Пример:
#include <iostream>
 using namespace std;
struct xampl {
    	int x;
};
int main(){
   	 xampl structure;
    	xampl *ptr;
    	structure.x = 12;
    	ptr = &structure;
   	 cout<< ptr->x;
    	cin.get();
	return 0;
}
