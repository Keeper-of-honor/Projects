Четырнадцатый(14) Вопросы
1) Язык C++. Числовые типы данных. Операции

Основные типы данных:
char     | 1 байт 	 | -128 ... 127
int    	   | 2 байта  | -32767 ... 32768
float	   | 4  байта | 3.4E-38 ... 3.4E38
double | 8 байтов | 1.7E-308 ... 1.7E308

Над данными целочисленных типов: %, >>, <<.&, |, ^, ~, >>=, <<=, &=, |=, ^=, &&, ||, !
Над данными всех числовых типов: +. - (бинарный и унарный), *, /, =, +=, *=, /=, ++, --, >, <, >=, <=, ==, !=
Операция sizeof
Операция sizeof внешне выглядит весьма странно (она похожа на функцию), но это именно операция. Аргументом операции sizeof может быть имя типа или данное любого типа. Операция возвращает количество байт, которое занимает аргумент в памяти. Приведем пример:
#include <stdio.h>
void main(void)
{ 
printf("\nint\t%d\nl\t%d\nlL\t%d\n0.1\t%d\nchar\t%d\n\'a\'\t%d\n",
  	sizeof(int),sizeof(l),sizeof(lL),sizeof(0.1),sizeof(char),sizeof('a'));
}

 Арифметические операции над вещественными данными
Ничего существенно интересного об операциях над данными вещественного типа сказать нельзя, поэтому просто ограничимся их перечислением: +,-, *, /, ++, -- (последние две операции могут быть префиксными и постфиксными),
    1. Операции отношения
Операции отношения (>,>=,<,<=,==, !=) также совсем простые, и особенностей, связанных с их использованием, практически нет. Следует обратить внимание, что результатом операции отношения является целое число (обычно 0, если результат операции "ложь", и 1, если "истина"; но гарантируется лишь то, что при "лжи" вырабатывается 0, а при "истине" — значение, отличное от нуля). Также надо обязательно обратить внимание (об этом еще пойдет речь ниже) на то, что сравнение на равенство записывается с использованием двух знаков равенства.
    2. Логические операции
С логическими операциями, которых всего три (&&, | | , ! ), надо быть внимательными и не путать их с битовыми. Дело в том, что с точки зрения компилятора оба выражения: (а==1)&&(b>2) и (а==1)&(b>2) являются синтаксически правильными. Ведь в результате выполнения операций отношения == и > получаются целые числа, с которыми можно производить как логическую операцию & &, так и битовую операцию &. Подобные ошибки зачастую бывает весьма трудно "поймать", и они портят немало нервов и ученикам, и учителю.
    3. Операция присваивания
С операцией присваивания для тех, кто изучает Си после Паскаля, иногда возникают проблемы. Самое важное: в Си присваивание — именно операция, а не оператор, как в Паскале. Как и всякая другая, операция присваивания вырабатывает значение, которое может использоваться в выражениях. Самый простой пример, иллюстрирующий сказанное, следующий. Пусть нам нужно присвоить одно и то же значение нескольким переменным. В Паскале это можно сделать лишь последовательными присваиваниями: а:=1; b:=1; с:=1. В Си запись короче: a=b=c=l;.
Для любой бинарной операции ор запись а=а ор b (понятно, что имена переменных могут быть и другими) может быть заменена более короткой (и более эффективной при реализации в машинном коде) записью:
а ор= b. Пример: выражение а=а+b; можно переписать в виде a+=b;.
    4. Операция запятая 
Весьма специфическая операция "запятая" используется для связывания нескольких выражений в одно. Пример ее использования будет приведен чуть ниже, при рассмотрении управляющих конструкций (в частности, цикла for).
    5. Операция приведения к типу
При рассмотрении операций над целыми числами (конкретно — операции деления) мы уже приводили "опасный" пример:
float с;
     с=1/2;
и объяснили, почему переменная с получит значение 0. Там же был указан и выход из положения — явно записать одно из чисел (или оба) как вещественное:
float с;
      с=1./2;
Но такой прием работает, когда речь идет о числах, а как быть, когда вместо чисел у нас имеются, например, целые переменные? Приведем соответствующий пример:
float с;
      int a=l,b=2;
      c=a/b;
bool: логический тип. Может принимать одну из двух значений true (истина) и false (ложь). Размер занимаемой памяти для этого типа точно не определен.

char: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255

signed char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

unsigned char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

wchar_t: представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)

char16_t: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535

char32_t: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295

short: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).

Данный тип также имеет синонимы short int, signed short int, signed short.

unsigned short: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

Данный тип также имеет синоним unsigned short int.

int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long

Данный тип имеет синонимы signed int и signed.

unsigned int: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).

В качестве синонима этого типа может использоваться unsigned

long: представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта (32 бита).

У данного типа также есть синонимы long int, signed long int и signed long

unsigned long: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).

Имеет синоним unsigned long int.

long long: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита).

Имеет синонимы long long int, signed long long int и signed long long.

unsigned long long: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита).

Имеет синоним unsigned long long int.

float: представляет вещественное число ординарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)

double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)

long double: представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.
