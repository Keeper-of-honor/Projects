LSEEK(2)                  Linux Programmer's Manual                  LSEEK(2)

NNAAMMEE
       lseek - reposition read/write file offset

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssyyss//ttyyppeess..hh>>
       ##iinncclluuddee <<uunniissttdd..hh>>

       ooffff__tt llsseeeekk((iinntt _f_d,, ooffff__tt _o_f_f_s_e_t,, iinntt _w_h_e_n_c_e));;

DDEESSCCRRIIPPTTIIOONN
       llsseeeekk() repositions the file offset of the open file description asso‐
       ciated with the file descriptor _f_d to the argument _o_f_f_s_e_t according to
       the directive _w_h_e_n_c_e as follows:

       SSEEEEKK__SSEETT
              The file offset is set to _o_f_f_s_e_t bytes.

       SSEEEEKK__CCUURR
              The  file  offset  is  set  to its current location plus _o_f_f_s_e_t
              bytes.

       SSEEEEKK__EENNDD
              The file offset is set to the size  of  the  file  plus  _o_f_f_s_e_t
              bytes.

       llsseeeekk()  allows  the  file offset to be set beyond the end of the file
       (but this does not change the size of the file).   If  data  is  later
       written  at  this  point,  subsequent  reads of the data in the gap (a
       "hole") return null bytes ('\0') until data is actually  written  into
       the gap.

   SSeeeekkiinngg ffiillee ddaattaa aanndd hhoolleess
       Since  version 3.1, Linux supports the following additional values for
       _w_h_e_n_c_e:

       SSEEEEKK__DDAATTAA
              Adjust the file offset to the next location in the file greater
              than  or  equal to _o_f_f_s_e_t containing data.  If _o_f_f_s_e_t points to
              data, then the file offset is set to _o_f_f_s_e_t.

       SSEEEEKK__HHOOLLEE
              Adjust the file offset to the next hole  in  the  file  greater
              than or equal to _o_f_f_s_e_t.  If _o_f_f_s_e_t points into the middle of a
              hole, then the file offset is set to _o_f_f_s_e_t.  If  there  is  no
              hole  past  _o_f_f_s_e_t, then the file offset is adjusted to the end
              of the file (i.e., there is an implicit hole at the end of  any
              file).

       In  both  of  the above cases, llsseeeekk() fails if _o_f_f_s_e_t points past the
       end of the file.

       These operations allow applications to map holes in a  sparsely  allo‐
       cated  file.   This can be useful for applications such as file backup
       tools, which can save space when creating backups and preserve  holes,
       if they have a mechanism for discovering holes.

       For  the  purposes  of these operations, a hole is a sequence of zeros
       that (normally) has not been allocated in the underlying file storage.
       However,  a filesystem is not obliged to report holes, so these opera‐
       tions are not a guaranteed mechanism for mapping the storage space ac‐
       tually  allocated  to  a file.  (Furthermore, a sequence of zeros that
       actually has been written to the underlying storage  may  not  be  re‐
       ported  as  a hole.)  In the simplest implementation, a filesystem can
       support the operations by making SSEEEEKK__HHOOLLEE always return the offset of
       the  end of the file, and making SSEEEEKK__DDAATTAA always return _o_f_f_s_e_t (i.e.,
       even if the location referred to by _o_f_f_s_e_t is a hole, it can  be  con‐
       sidered to consist of data that is a sequence of zeros).

       The  __GGNNUU__SSOOUURRCCEE feature test macro must be defined in order to obtain
       the definitions of SSEEEEKK__DDAATTAA and SSEEEEKK__HHOOLLEE from _<_u_n_i_s_t_d_._h_>.

       The SSEEEEKK__HHOOLLEE and SSEEEEKK__DDAATTAA operations are supported for the following
       filesystems:

       *  Btrfs (since Linux 3.1)

       *  OCFS (since Linux 3.2)

       *  XFS (since Linux 3.5)

       *  ext4 (since Linux 3.8)

       *  ttmmppffss(5) (since Linux 3.8)

       *  NFS (since Linux 3.18)

       *  FUSE (since Linux 4.5)

RREETTUURRNN VVAALLUUEE
       Upon successful completion, llsseeeekk() returns the resulting offset loca‐
       tion as measured in bytes from the beginning of the file.   On  error,
       the  value _(_o_f_f___t_) _-_1 is returned and _e_r_r_n_o is set to indicate the er‐
       ror.

EERRRROORRSS
       EEBBAADDFF  _f_d is not an open file descriptor.

       EEIINNVVAALL _w_h_e_n_c_e is not valid.  Or: the resulting file  offset  would  be
              negative, or beyond the end of a seekable device.

       EENNXXIIOO  _w_h_e_n_c_e is SSEEEEKK__DDAATTAA or SSEEEEKK__HHOOLLEE, and the file offset is beyond
              the end of the file.

       EEOOVVEERRFFLLOOWW
              The resulting file offset cannot be represented in an _o_f_f___t.

       EESSPPIIPPEE _f_d is associated with a pipe, socket, or FIFO.

CCOONNFFOORRMMIINNGG TTOO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

       SSEEEEKK__DDAATTAA and SSEEEEKK__HHOOLLEE are nonstandard extensions also present in So‐
       laris,  FreeBSD, and DragonFly BSD; they are proposed for inclusion in
       the next POSIX revision (Issue 8).

NNOOTTEESS
       See ooppeenn(2) for a discussion of the relationship between file descrip‐
       tors, open file descriptions, and files.

       If  the OO__AAPPPPEENNDD file status flag is set on the open file description,
       then a wwrriittee(2) _a_l_w_a_y_s moves the file offset to the end of  the  file,
       regardless of the use of llsseeeekk().

       The  _o_f_f___t  data  type  is  a  signed  integer  data type specified by
       POSIX.1.

       Some devices are incapable of seeking and POSIX does not specify which
       devices must support llsseeeekk().

       On  Linux, using llsseeeekk() on a terminal device fails with the error EESS‐‐
       PPIIPPEE.

SSEEEE AALLSSOO
       dduupp(2),  ffaallllooccaattee(2),   ffoorrkk(2),   ooppeenn(2),   ffsseeeekk(3),   llsseeeekk6644(3),
       ppoossiixx__ffaallllooccaattee(3)

CCOOLLOOPPHHOONN
       This  page  is part of release 5.05 of the Linux _m_a_n_-_p_a_g_e_s project.  A
       description of the project, information about reporting bugs, and  the
       latest     version     of    this    page,    can    be    found    at
       https://www.kernel.org/doc/man-pages/.

Linux                             2019-03-06                         LSEEK(2)
